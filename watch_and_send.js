/**
 *  The Corelink Sender logic, utilizing chokidar to watch for new avi frames generated by Miniscope, and send to 
 *  Corelink raw image workspace. Each frame is sent as a chunk, with a 2 byte frame number, 1 byte chunk index, and 1 byte for total chunks.
 *  When the current frame finishes sending, a END_FRAME message will be sent. When there is one second of inactivation, the sender will
 *  be indicated stale, thus sending a FINISHED message to Corelink. 
 * 
 *  Author: Kaiwen Guo 
 */


// Importing required libraries and path. 
const fs = require('fs');
const chokidar = require('chokidar');
const path = require('path');
const corelink = require('corelink-client');

// Initializing the configurations required to use Corelink service. 
const config = {
  ControlPort: 20012,
  ControlIP: 'corelink.hpc.nyu.edu',
  autoReconnect: false,
};

// Configurations for the sender.
const username = 'Testuser';
const password = 'Testpassword';
const workspace = 'Fenton';
const protocol = 'ws';
const datatype = 'distance';
const CHUNK_SIZE = 4 * 1024; // 4KB chunk size

// Should be set to false for production. 
corelink.debug = true;


let receiverActive = false;
let sender;
let currentFrameNumber = 0;
let inactiveTimeout;

async function sendFile(filePath) {
  return new Promise((resolve, reject) => {
    fs.readFile(filePath, (err, fileBuffer) => {
      if (err) return reject(err);

      const totalChunks = Math.ceil(fileBuffer.length / CHUNK_SIZE);

      for (let i = 0; i < totalChunks; i++) {
        const chunk = fileBuffer.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
        const frameNumberBuffer = Buffer.alloc(2);
        frameNumberBuffer.writeUInt8(currentFrameNumber >> 8, 0);
        frameNumberBuffer.writeUInt8(currentFrameNumber & 0xFF, 1);
        const dataToSend = Buffer.concat([
          frameNumberBuffer,
          Buffer.from([i, totalChunks]),
          chunk,
        ]);

        if (receiverActive) {
          corelink.send(sender, dataToSend);
          console.log('Chunk sent:', i, 'of frame', currentFrameNumber);
        }
      }
      resolve();
    });
  });
}

// Function to send an end message
async function sendEndMessage() {
  if (receiverActive) {
    const endMessage = Buffer.from('FINISHED');
    corelink.send(sender, endMessage);
    console.log('End message sent.');
  }
}

// Initialize Corelink and watch for new files
const run = async () => {
  try {
    await corelink.connect({ username, password }, config);
    sender = await corelink.createSender({
      workspace,
      protocol,
      type: datatype,
      metadata: { name: 'AVI File Sender' },
    });

    corelink.on('sender', async (data) => {
      if (!!data.receiverID !== receiverActive) {
        receiverActive = !!data.receiverID;
        console.log(`Receiver ${data.receiverID} ${receiverActive ? 'connected' : 'disconnected'}.`);
      }
    });

    // Watch directory from environment variable or default
    const watchDir = process.env.WATCH_DIR || "C:/Users/Research/Desktop/temp/GarrettBlair/PKCZ_imaging/test";

    const watcher = chokidar.watch(watchDir, {
      persistent: true,
      ignoreInitial: true,
      followSymlinks: false,
      depth: 3,
      awaitWriteFinish: {
        stabilityThreshold: 2000,
        pollInterval: 100,
      },
      usePolling: true,
    });

    watcher.on('add', async (filePath) => {
      if (path.extname(filePath).toLowerCase() === '.avi') {
        console.log(`New video file detected: ${filePath}`);
        clearTimeout(inactiveTimeout);
    
        if (receiverActive) {
          sendFile(filePath).then(() => {
            currentFrameNumber++;
          }).catch(err => {
            console.error('Failed to send file:', err);
          });
        } else {
          console.log('Receiver not active. Skipping file:', filePath);
        }
    
        inactiveTimeout = setTimeout(async () => {
          await sendEndMessage();
        }, 1000);
      }
    });
    
    console.log(`Watching for new .avi files in ${watchDir}`);
  } catch (err) {
    console.error('Error:', err);
  }
};

run();
